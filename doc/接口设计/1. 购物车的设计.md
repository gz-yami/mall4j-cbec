建议阅读前，先阅读《商城表设计-购物车》相关文档

我们的购物车只有一个表：`tz_basket` 非常简单，但是关联了非常多的表。比如：

- 购物车有商品，关联商品表
- 每个商品都有sku，关联sku表
- 一个购物车有多个店铺的商品，关联店铺表
- 一个购物车肯定是和用户有关的，关联用户表



我们对商品进行添加，修改，其实都很简单，最为让人难以理解的是如何将这些字段进行组合，关联满减满折等一系列的活动。

我们先来看下是如何获取商品信息的

```java
    @PostMapping("/info")
    @Operation(summary = "获取用户购物车信息" , description = "获取用户购物车信息，参数为用户选中的活动项数组")
    @Parameter(name = "addrId", description = "地址id")
    public ServerResponseEntity<ShopCartWithAmountVO> info(@RequestParam(value = "addrId" , required = false, defaultValue = "0") Long addrId) throws ExecutionException, InterruptedException {
        String userId = SecurityUtils.getUser().getUserId();
        // 拿到购物车的所有item
        List<ShopCartItemDto> shopCartItems = shopCartItemAdapter.getShopCartItems(userId, addrId);
        List<ShopCartItemDto> filterShopCartItems = shopCartItems.stream()
                .filter(shopCartItemDto -> Objects.equals(shopCartItemDto.getIsChecked(), 1)).collect(Collectors.toList());
        // 组合每个店铺的购物车信息
        List<ShopCartDto> shopCarts = shopCartAdapter.getShopCarts(shopCartItems);
        ShopCartWithAmountVO shopCartWithAmount = new ShopCartWithAmountVO();
        shopCartWithAmount.setShopCarts(shopCarts);
        // 购物车项，按购物id顺序倒序返回
        for (ShopCartDto shopCart : shopCarts) {
            for (ShopCartItemDiscountDto shopCartItemDiscount : shopCart.getShopCartItemDiscounts()) {
                shopCartItemDiscount.getShopCartItems().sort(Comparator.comparing(ShopCartItemDto::getBasketId).reversed());
            }
        }
        // 重新计算下运费
        List<DvyTypeDTO> dvyTypes = Collections.singletonList(new DvyTypeDTO(null, DeliveryType.EXPRESS.getValue()));
        UserDeliveryInfoVO userDeliveryInfoVO = deliveryOrderManager.calculateAndGetDeliverInfo(userId, addrId, filterShopCartItems, dvyTypes);
        shopCartWithAmount.setUserDeliveryInfo(userDeliveryInfoVO);
        this.calculateMakeUpShopCartAndAmount(shopCartWithAmount);
        return ServerResponseEntity.success(shopCartWithAmount);
    }
```

这里面传了一个参数：`addrId` 这里是当用户改变了收货地址，重新改变满减满折信息以后计算加个的一个方法。当然在开源是没有这个满减模块的，只有思路，具体实现需要靠自己了。

我们继续往下看，这里面`shopCartItemAdapter.getShopCartItems(userId, addrId)`使用的直接是从数据库中获取的数据，而真正对满减满折、店铺等进行排列组合的，在于`shopCartAdapter.getShopCarts(shopCartItems)` 这个方法。



我们进到`getShopCarts`方法内部，可以查看到一行代码`buildShopCart(shopId, shopCartItemDtoList)`，这里用于对模块之间的解耦，比如我们清楚的知道当购物车需要计算价格的时候，需要满减模块的配合，进行“装饰”。最后将装饰回来的东西，返回给前端。 



我们现在看看购物车返回的数据`ServerResponseEntity<List<ShopCartDto>>`，我们清楚一个购物车是分多个店铺的，每一个店铺就是一个`ShopCartDto`，我们看下这个`bean`。

```java
@Data
public class ShopCartDto implements Serializable {

   @Schema(description = "店铺ID" ,requiredMode = Schema.RequiredMode.REQUIRED)
   private Long shopId;

   @Schema(description = "店铺名称" ,requiredMode = Schema.RequiredMode.REQUIRED)
   private String shopName;

   @Schema(description = "购物车满减活动携带的商品" ,requiredMode = Schema.RequiredMode.REQUIRED)
   private List<ShopCartItemDiscountDto> shopCartItemDiscounts;

}
```

其实一个店铺下面是有多个商品的，但是根据京东的划分，每当有满减之类的活动时，满减活动的商品总是要归到一类的，所以，每个店铺下面是多个满减活动（`List<ShopCartItemDiscountDto>`），满减活动下面是多个商品（购物项`List<ShopCartItemDto>`），到此你就能明白了`ShopCartItemDiscountDto` 里面的`ChooseDiscountItemDto` 是什么东西了，这个是选中的满减项。

```java
public class ShopCartItemDiscountDto implements Serializable {

    @Schema(description = "已选满减项" ,requiredMode = Schema.RequiredMode.REQUIRED)
    private ChooseDiscountItemDto chooseDiscountItemDto;

    @Schema(description = "商品列表" )
    private List<ShopCartItemDto> shopCartItems;
}
```

```java
    @PostMapping("/changeItem")
    @Operation(summary = "添加、修改用户购物车物品", description = "通过商品id(prodId)、skuId、店铺Id(shopId),添加/修改用户购物车商品，并传入改变的商品个数(count)，" +
            "当count为正值时，增加商品数量，当count为负值时，将减去商品的数量，当最终count值小于0时，会将商品从购物车里面删除")
    public ServerResponseEntity<Integer> changeItem(@Valid @RequestBody ChangeShopCartParam param) {
        String userId = SecurityUtils.getUser().getUserId();
        List<ShopCartItemDto> shopCartItems = shopCartItemAdapter.getShopCartItems(userId, 0L);

        Product product = productService.getProductByProdId(param.getProdId());
        Sku sku = skuService.getSkuBySkuId(param.getSkuId());
        //商品已下架
        if(Objects.equals(product.getStatus(), StatusEnum.DISABLE.value()) || Objects.equals(product.getStatus(), StatusEnum.DELETE.value())){
            return ServerResponseEntity.showFailMsg(I18nMessage.getMessage("yami.product.disable"));
        }
        // 当商品状态不正常时，不能添加到购物车
        boolean noTakeOff = !Objects.equals(product.getStatus(), ProdStatusEnums.NORMAL.getValue()) || !Objects.equals(sku.getStatus(), StatusEnum.ENABLE.value())
                // 当商品为预售商品时，不能添加到购物车
                || (Objects.nonNull(product.getPreSellStatus()) && Objects.equals(product.getPreSellStatus(), 1))
//                // 当商品为虚拟商品时，不能添加到购物车
//                || Objects.equals(product.getMold(), 1)
                // 当商品为活动商品时，不能添加到购物车
                || Objects.equals(product.getProdType(), ProdType.PROD_TYPE_ACTIVE.value());
        if (noTakeOff) {
            // 预售/活动商品不能加入购物车！
            return ServerResponseEntity.showFailMsg(I18nMessage.getMessage("yami.shopCart.prod.error"));
        }

        Integer skuStock = sku.getStocks();
        // 返回购物车数量
        return getBasketNum(shopCartItems, userId, param, skuStock);
    }
```


其实购物车的每个购物项，都是有很多个满减的活动的，可以自主选择满减活动，然后进行组合，生成新的优惠。而在这选择新的活动类型时，就需要购物车就行新的价格计算。调用这个方法可以修改购物车的优惠活动等，然后重新获取购物车数据
